---
title: "Práticas em Bioinfo II"
author: "Prof. Heron OH"
place: "Biomedicina - PUC Minas"
date: 2023/01
output: 
  rmdformats::downcute:
    code_folding: show
    self_contained: true
    toc_depth: 5
    toc_float: yes
    highlight: zenburn
    code_download: yes
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r color, echo=FALSE, results='asis'}
#configurar pros resultados do bash sairem coloridos e não ANSI

old_hooks <- fansi::set_knit_hooks(
  knitr::knit_hooks, 
  which = c("output", "message", "error")
)
```

<style>
body {
text-align: justify}
</style>

<style>
#toc ul.nav li ul li {
    display: none;
    max-height: none;
}

#toc ul.nav li.active ul li  {
    display: block;
    max-height: none;
}

#toc ul.nav li ul li ul li {
    max-height: none;
    display: none !important;
}

#toc ul.nav li ul li.active ul li {
    max-height: none;
    display: block !important;
}
</style>


# Práticas em bioinformática

&nbsp;&nbsp;&nbsp;&nbsp;
Olá, esta é mais uma de um conjunto de práticas em bioinformática desenvolvidas para o curso de Biomedicina da PUC MG.
Você pode encontrar as demais práticas [*aqui*](https://heronoh.github.io/bioinfo).

## Comandos básicos II

### _Inputs_ & _outputs_

&nbsp;&nbsp;&nbsp;&nbsp;
As operações que o computador executa - seja através de programas, _scripts_, aplicativos ou comandos - funcionam a partir do que chamamos de ***input*** (ou _entrada_). ***Inputs*** podem ser tanto arquivos, quanto parâmetros e argumentos necessários para a execução da operação. 

&nbsp;&nbsp;&nbsp;&nbsp;
De maneira semelhante, tudo o que é gerado pelo comando (ou programa, _script_, aplicativo, ...) é denominado ***output***.

&nbsp;&nbsp;&nbsp;&nbsp;
Na _linha de comando_ é possível encadear diversos comandos sequencialmente, de maneira que o ***input*** do primeiro comando seja o ***output*** do próximo. Isto é conseguido pelo uso do ***pipe***, identificado por uma barra vertical (**|**). Assim, um conjunto de comandos encadeados por ***pipes*** pode ser denominado ***pipe line***, termo que pode ser expandido para representar qualquer conjunto de análise sequenciais para a transformação de um ***input*** em algum ***output***. Mas, antes de trabalharmos com ***pipes***, vamos primeiramente escrever alguns arquivos.  

### Tipos de arquivos 

&nbsp;&nbsp;&nbsp;&nbsp;
Um arquivo é uma entidade que pode armazenar qualquer coisa, e pode ser codificado de duas maneiras:

**Arquivos binários:* um arquivo binário contém código legível por máquina que pode ser executado diretamente pelo processador de um computador. Ele armazena dados em [formato binário](https://pt.wikipedia.org/wiki/Arquivo_bin%C3%A1rio), o que significa que usa uma série de 0's e 1's para representar informações. Estes formatos são normalmente usados para _programas executáveis_, _bibliotecas_ e outros arquivos que contêm _código compilado_, ou seja, um conjunto de instruções que já foi transformado da _linguagem de programação_ original para um _código de máquina_, pronto para ser interpretado pelo processador. *Arquivos binários* não podem ser facilmente lidos ou editados por humanos e geralmente requerem ferramentas ou programas especiais para trabalhar com eles.

**Arquivo de texto:* um arquivo de texto armazena dados como uma sequência de caracteres que podem ser lidos e editados por humanos. Os [arquivos de texto](https://pt.wikipedia.org/wiki/Arquivo_de_texto) geralmente são codificados usando conjuntos de caracteres *ASCII* ou *Unicode* e podem ser criados e editados usando uma ampla variedade de editores de texto. Os formatos de arquivo de texto são comumente usados para armazenar arquivos de configuração, arquivos de dados e outros tipos de conteúdo legível por humanos.

&nbsp;&nbsp;&nbsp;&nbsp;
Em resumo, os formatos de _arquivo binário_ são otimizados para processamento por máquina, enquanto os formatos de _arquivo de texto_ são otimizados para legibilidade e edição por humanos. Ambos formatos podem ser convertidos um no outro.

&nbsp;&nbsp;&nbsp;&nbsp;
Há diferentes maneiras de se organizar as informações contidas em cada tipo de arquivo.  A esses tipos de organização damos o nome de ***formato***. O formato de cada arquivo é evidenciado pela sua extensão, que é uma abreviação incluída ao final do nome de cada arquivo. Por exemplo, arquivos de texto do _Microsoft Word_ são identificados pelo sufixo _.docx_. Mas, além da identificação pelo nome, a estrutura interna é o que realmente determina o formato, sendo o sufixo apenas um facilitador. 

&nbsp;&nbsp;&nbsp;&nbsp;
Alguns exemplos de formatos de arquivo de texto incluem:

**Arquivos de texto simples:* Esses arquivos contêm apenas texto sem formatação, como arquivos _.txt_. Eles são fáceis de criar e editar, mas não oferecem suporte a recursos avançados de formatação de texto, como negrito, itálico, cores etc.

**Arquivos de texto com marcação:* Esses arquivos incluem texto com marcação, como arquivos _.html_, _.xml_ ou _.markdown_. A marcação é usada para adicionar informações sobre a estrutura do documento, como títulos, parágrafos, listas e links. Os arquivos de texto com marcação são usados principalmente na web para exibir conteúdo em navegadores.

**Arquivos de texto delimitados:* Esses arquivos contêm dados tabulares, onde cada coluna de dados é separada por um caractere de delimitação, como uma vírgula ou um ponto-e-vírgula. Exemplos de formatos de arquivo de texto delimitados incluem _.csv_, _.tsv_ e _.txt_. Eles são amplamente utilizados para armazenar dados em planilhas e bancos de dados.

**Arquivos de texto estruturados:* Esses arquivos contêm dados organizados em uma estrutura específica, como arquivos _.json_, _.yaml_ ou _.ini_. Eles são usados principalmente para armazenar configurações, opções e outros dados que precisam ser organizados hierarquicamente.

### Escrevendo arquivos

&nbsp;&nbsp;&nbsp;&nbsp;
Na prática passada ulitizamos alguns comandos para criar e modificar arquivos. Agora, iremos aprender outros comandos para escrever e editar arquivos.

#### Via linha de comando

&nbsp;&nbsp;&nbsp;&nbsp;
O resultado (***output***) de qualquer comando pode ser escrito diretamente em um arquivo. Isto pode ser feito utilizando os sinais ***>*** & ***>>***. Estes sinais representam a ação de adicionar conteúdo a um arquivo. Enquanto o segundo, ***>>***, adiciona conteúdo ao final de um arquivo, o primeiro, ***>***, reescreve totalmente seu conteúdo, apagando qualquer informação existente. Vamos fazer algumas experimentações.

> Com o comando ***echo***, crie algum conteúdo e salve ele num arquivo, utilizando o operadore de escrita em arquivos ***>>***. Em seguida, visualize o conteúdo do arquivo com o comando ***cat***.

```{bash, echo=TRUE,eval=FALSE}

echo "linha 1" >> arquivo.txt
echo "linha 2" >> arquivo.txt
echo "linha 3" >> arquivo.txt
echo "linha 4" >> arquivo.txt
echo "linha 5" >> arquivo.txt

cat arquivo.txt

```

&nbsp;&nbsp;&nbsp;&nbsp;
Observe que todas as linhas foram armazenadas no arquivo. Vamos ver o que acontece com o outro operador.

> Com o comando ***echo***, crie algum conteúdo e salve ele num arquivo, utilizando o operadore de escrita em arquivos ***>***. Em seguida, visualize o conteúdo do arquivo com o comando ***cat***.

```{bash, echo=TRUE,eval=FALSE}
echo "linha 1" > arquivo2.txt

cat arquivo2.txt

echo "linha 2" > arquivo2.txt
echo "linha 3" > arquivo2.txt
echo "linha 4" > arquivo2.txt
echo "linha 5" > arquivo2.txt

cat arquivo2.txt
```


&nbsp;&nbsp;&nbsp;&nbsp;
Observe que apenas a última linha está armazenada no arquivo. Todas as demais foram armazenadas, porém foram sobreescritas a cada novo comando.

> Agora, remova os arquivos que você gerou, para mantermos a organização de nossas pastas.

```{bash, echo=TRUE,eval=FALSE}

rm arquivo.txt
rm arquivo2.txt

```

#### Com editor de texto (vi)

&nbsp;&nbsp;&nbsp;&nbsp;
Editores de texto são programas que permitem você abrir arquivos de texto e editar seu conteúdo. Há diversas opções disponíveis, com várias funcionalidades diferentes. Nos sistemas operacionais ***Linux***, o editor de texto padrão é o [Vi](https://pt.wikipedia.org/wiki/Vi), também disponível como ***Vim*** (uma abreviação de _Vi IMproved_). 

&nbsp;&nbsp;&nbsp;&nbsp;
Como não existe _mouse_ na linha de comando, a interação com o editor de texto é toda feita utilizando _atalhos de teclado_. Atalhos são combinações de teclas que geram ações. Cada programa ou _ambiente_ tem seus próprios atalhos. Na dúvida sobre as opções, utilize ferramentas de busca como o [_Google_](https://www.google.com/) para fazer buscas, utilizando palavras-chave como, neste caso. Estas buscas podem ser feitas em qualquer idioma, mas é mais fácil de conseguir uma variedade maior de resultados quando a busca é feita em _inglês_, visto que esta é a língua atualmente adotada como _universal_, tanto pela ciência quanto pela informática.

&nbsp;&nbsp;&nbsp;&nbsp;
Por exemplo, neste caso, façamos a busca com as seguintes _palvras-chave_:

> vi linux atalhos

&nbsp;&nbsp;&nbsp;&nbsp;
Explore os resultados e veja que há muitas opções de atalhos. 

&nbsp;&nbsp;&nbsp;&nbsp;
Mas não se assuste, aqui vai uma relação dos principais atalhos que você vai precisar. Estes comandos só funcionam estando *fora* do **modo de inserção**, que é o modo onde qualquer tecla é escrita como texto no arquivo. Para saber se você está no **modo de inserção**, basta observar o canto inferior esquerdo da tela do editor. Se você estiver no **modo de inserção**, verá lá escrito:

> \-- INSERT \-- 

```{r atalhos_vi, echo=FALSE}

# library(tidyverse)


atalhos_vi <-  c(
                "i" = "ativar o ***modo de inserção***",
                "esc" = "sair do ***modo de inserção***",
                ":" = "sinalizar uma ação",
                ":w" = "salvar o arquivo",
                ":wq" = "salvar o arquivo e sair do programa",
                ":q!" = "sair do programa SEM salvar o arquivo",
                "**Del**" = "deletar conteúdo à frente do cursor",
                "**Backspace**" = "deletar conteúdo para trás do cursor",
                "botão direito do mouse" = "copiar texto selecionado",
                "botão direito do mouse" = "colar texto copiado",
                "dd" = "deletar a linha onde está o cursor",
                "yy" = "copiar a linha onde está o cursor",
                "p" = "colar a linha onde está o cursor",
                "/xxx" = "buscar o padrão *xxx* no conteúdo do arquivo"
                
                ) 
    
atl_vi_tbl <- dplyr::tibble("Comando" = names(atalhos_vi),
                            "Ação" = atalhos_vi)

knitr::kable(atl_vi_tbl,
             format = "pandoc")

```


### Escrevendo _scripts_

&nbsp;&nbsp;&nbsp;&nbsp;
Os ***scripts*** estão para a _bioinformática_ assim como as _receitas_ estão para a _culinária_. Os _ingredientes_ são o ***inputs***, e todos os comandos, programas, funções e possibilidades, que podem ser combinados de diversas maneiras e em ordem variada, para se obter o prato final, o ***output***.

&nbsp;&nbsp;&nbsp;&nbsp;
Uma vez que você tem em mente uma sequência de procedimentos que queira realizar e repetir, você pode organizá-los num _arquivo_ que será lido pelo computador como uma _receita_. Isto te poupará o tempo de ter que ficar repetindo comandos, além de previnir os _erros_ que sempre ocorrem em qualquer repetição _não programática_, quando se faz algo manualmente. Outra vantagem é que os ***scripts*** possibilitam automatização e paralelização, ou seja, o computador pode fazer por você uma mesma tarefa, várias vezes ao mesmo tempo, para um conjunto de ***inputs*** semelhantes.



```{bash, echo=TRUE,eval=FALSE}
echo "linha 1" > arquivo2.txt

cat arquivo2.txt

echo "linha 2" > arquivo2.txt
echo "linha 3" > arquivo2.txt
echo "linha 4" > arquivo2.txt
echo "linha 5" > arquivo2.txt

cat arquivo2.txt
```






## Exercícios

&nbsp;&nbsp;&nbsp;&nbsp;
Utilizando os comandos que você aprendeu, execute as instruções a seguir. Sempre que pssível, utilize a tecla $TAB$ para completar os nomes de arquivos e caminhos. Lembre-se que o caracter $*$ serve como _coringa_, ele representa qualquer outro caracter.

> 1) mova os arquivos cujo nome começa com _arquivo_1_, _arquivo_2_ e _arquivo_3_ da pasta de onde eles foram criados para a pasta correspondente à última letra de seus nomes.

&nbsp;&nbsp;&nbsp;&nbsp;
Tente, com um único comando:

> 2) remover os arquivos com numeração _3_ de todas as pastas.

&nbsp;&nbsp;&nbsp;&nbsp;
Agora, vejamos como ficou a organização.

> 3) visualize a distribuição das subpastas e arquivos dentro da pasta _aula1_.



>>>> Voltar para a [*página inicial*](https://heronoh.github.io/bioinfo)






