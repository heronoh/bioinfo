---
title: "Práticas em Bioinformática"
author: "Prof. Heron OH"
place: "Biomedicina - PUC Minas"
date: 2023/01
output: 
  rmdformats::readthedown:
    code_download: yes
  html_document: 
    toc: yes
    toc_depth: 3
    toc_float: yes
    highlight: zenburn
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r color, echo=FALSE, results='asis'}
#configurar pros resultados do bash sairem coloridos e não ANSI

old_hooks <- fansi::set_knit_hooks(
  knitr::knit_hooks, 
  which = c("output", "message", "error")
)
```

<style>
body {
text-align: justify}
</style>



## Linux e WSL

&nbsp;&nbsp;&nbsp;&nbsp;
Praticamente todos os computadores dedicados a análises de bioinformática rodam sistemas operacionais do tipo ***Unix***, em especial o ***Linux*** e o ***macOS***. Em nossas práticas na _linha de comando_, utilizaremos o sistema operacional [**Ubuntu**](https://ubuntu.com/). Caso o seu computador seja ***Windows***, você pode _emular_ um sistema operacional ***Unix*** utilizando o ***WSL***, ou _Windows subsystem for linux_.

&nbsp;&nbsp;&nbsp;&nbsp;
Você pode conferir as instruções de instalação originais da Microsoft [aqui](https://learn.microsoft.com/en-us/windows/wsl/install).
Mas, resumidamente, para habilitar o ***WSL*** você precisa que o seu computador tenha as aseguintes especificações.

* Windows 10 versão 2004 ou superior.
* _Build_ 19041 ou superior.

### Compatibildiade com WSL

Para conferir esses atributos, proceda da seguinte maneira:


> No seu teclado, aperte conjuntamente as teclas _win key_ (`r knitr::asis_output("\U229E")`) e _R_. Na janela que se abriu, digite _winver_ e pressione $enter$ (`r knitr::asis_output("\U21B5")`).

Compare as informações exibidas com os pré-requisitos acima. 

### Habilitar e instalar o WSL

> Aperte a tecla _win key_ (`r knitr::asis_output("\U229E")`). Uma janela se abrirá, contendo um campo de busca. Basta digitar _powershell_ que a opção do ***Windows Powershell*** será exibida. Clique na mesma com o botão direito e selecione _Abrir como administrador_.

&nbsp;&nbsp;&nbsp;&nbsp;
Uma janela azul se abrirá. Esta é a interface por linha de comando do Windows. Nela iremos digitar os comandos para a instalação do ***WSL***. Para a execução de cada comando, após digitar a instrução, basta apertar $enter$ (`r knitr::asis_output("\U21B5")`).

> Liste as distribuições de Linux disponíveis.

```{bash, echo=TRUE,eval=FALSE}
wsl --list --online
```

&nbsp;&nbsp;&nbsp;&nbsp;
Você verá uma lista das distribuições de Linux que podem ser instaladas no seu WSL. Utilizaremos a **Ubuntu-20.04**. Prossiga com a instalação.

> Inicie a instalação da distribuição desejada.

```{bash, echo=TRUE,eval=FALSE}
wsl --install -d Ubuntu-20.04
```

&nbsp;&nbsp;&nbsp;&nbsp;
Primeiro a distribuição (_distro_) será baixada, e depois instalada. Ao final da instalação, uma nova janela, de fundo preto, se abrirá. Este já é o Ubuntu, e as primeiras mensagens que você vai receber são para configurar o seu usuário.


&nbsp;&nbsp;&nbsp;&nbsp;
O primeiro passo será escolher um _login_, um nome para o seu usuário. Para facilitar, recomendo que o seu login:

* Seja curto, com no máximo 8 caracteres.
* Tenha apenas letras minúsculas.
* Não contenha caracteres especiais como _~_, _^_, _ç_, ...
* Não contenha espaços.

Uma vez definido o seu login, você será solicitado a criar um _password_, uma senha para o seu usuário. Uma vez que você está no seu próprio computador, ou num login institucional, sugiro criar uma senha mais simples, como _o nome do seu usuário + 12345_, pois será de fácil dadução caso você se esqueça durante estes primeiros passos.
Quando for utilizar usuários em computadores compartilhados ou em servidores, recomendo criar senhas o mais complicadas o possível, sem o nome do seu usuário.


## A linha de comando

&nbsp;&nbsp;&nbsp;&nbsp;
Todos os sistemas operacionais podem ser operados sem a necessidade de uma interface gráfica, ou seja, sem uma tela com ícones que você selecione clicando (_mouse_). Isto é realizado apenas atavés do teclado. A linha de comando é a interface por onde você transmite instruções escritas para o computador (***input***), que te retorna o resultado do processamento dessas instruções (***output***). Há uma infinidade de _comandos_ que podem ser executados, mas alguns que conheceremos nestas práticas são fundamentais no dia a dia do bioinformata.


## Comandos básicos

### Navegando em diretórios


&nbsp;&nbsp;&nbsp;&nbsp;
Para se trabalhar na linha de comando, é muito importante saber onde se está. O computador é organizado em diretórios (também chamados de pastas). Todos os diretórios estão contidos dentro de um diretório principal, o **diretório raiz**, representado pelo símbolo _barra_ (**/**). Todos os arquivos ou pastas do computador tem uma localização definida, e portanto, tem _endereços_. Para a execução de qualquer comando que atua sobre um arquivo deve ser fornecido o seu _endereço_. Para se evitar a ocorrencia de erros usamos, preferencialmente, **_endereços completos_**, ou seja, contendo todas as pastas a partir do diretório raiz, o **/** . Por exemplo:

> Na sua linha de comando (_bash_), escreva o seguinte comando e aperte ***ENTER***.

```{bash, echo=TRUE,eval=FALSE}
pwd
```


&nbsp;&nbsp;&nbsp;&nbsp;
O comando ***pwd*** retorna o _path to the working directory_, o caminho para o diretório que você está.


&nbsp;&nbsp;&nbsp;&nbsp;
Para mudarmos de diretório, utilizamos o comando ***cd***. Quando executado sem argumentos, ele te transporta para a ***\$HOME***, o diretório _casa_ do usuário, e que carrega seu nome. Este diretório geralmente está localizado em **/home/$usuário**.

&nbsp;&nbsp;&nbsp;&nbsp;
Você pode identificar qual é o seu usuário com o comando ***whoami***

> Identifique seu usuário.  

```{bash, echo=TRUE,eval=TRUE}
whoami

```
 No meu caso, estou utilizando o usuário _noreh_.

> Agora execute o comando ***cd***, sem argumentos, e verifique mais uma vez onde você está. 

```{bash, echo=TRUE,eval=FALSE}
cd

pwd
```

&nbsp;&nbsp;&nbsp;&nbsp;
Se você já estava na sua ***\$HOME***, você continua no mesmo lugar.



> Utilize o comando ***cd*** com argumentos, e verifique mais uma vez onde você está. 

```{bash, echo=TRUE,eval=FALSE}
cd ..

pwd

cd .

pwd

```

---

Estes argumentos representam _o diretório atual_ (***.***) e _o diretório acima do atual_ (***..***), e são utilizados em *caminhos relativos*, que em breve veremos com mais detalhes.


### Criando e modificando diretórios

&nbsp;&nbsp;&nbsp;&nbsp;
Agora vamos criar diretórios para explorar outros comandos. Para criar um diretório, utilizamos o comando ***mkdir***, seguido do nome do diretório a ser criado, com caminhos completos ou não. Caso não seja fornecido um caminho, o novo diretório será criado no diretório onde se está.

> Utilize o comando ***mkdir*** para criar uma pasta _aula1_, na sua ***$HOME***. Entre nessa pasta com ***cd***.

```{bash, echo=TRUE,eval=FALSE}
cd

mkdir aula1

cd aula1

```

> Utilize o comando ***mkdir*** para criar 3 pastas, _pasta_A_, _pasta_B_, _pasta_C_, dentro de _aula1_. Liste os arquivos do diretório onde você está com o comando ***ls***.

```{bash, echo=TRUE,eval=FALSE}

ls

mkdir pasta_A
mkdir pasta_B
mkdir pasta_C

ls
```

> O comando ***ls*** (assim como a grande maioria de comandos) aceita argumentos. Argumentos são elementos que modificam a maneira como cada comando funciona. Experimente a variação a seguir e veja a diferença.

```{bash, echo=TRUE,eval=FALSE}
ls -lh
```


&nbsp;&nbsp;&nbsp;&nbsp;
Você acaba de listar os arquivos e pastas, bem como outras informações. Da esquerda para a direita: a) tipo de arquivo e permissões; b) contagem de links; c) usuário e grupo proprietários do arquivo; d) tamanho do arquivo (em _bytes_); e) data da última modificação; f) nome do arquivo.


&nbsp;&nbsp;&nbsp;&nbsp; 
Agora vamos criar alguns arquivos. 

> Utilize o comando ***touch*** para criar dentro da pasta _pasta_A_ alguns arquivos.

```{bash, echo=TRUE,eval=FALSE}
cd pasta_A

touch arquivo_{1..3}_{A..D}
```

&nbsp;&nbsp;&nbsp;&nbsp; 
Veja que, com um comando apenas, você criou diversos arquivos (vazios). Isso acontece porque o uso de ***{}*** possibilita a representação de múltiplos caracteres. Faça experiencias com o comando ***echo***, que _imprime_ algum texto ou expressão.

> Faça experiencias com o comando ***echo***, que _imprime_ algum texto ou expressão.

```{bash, echo=TRUE,eval=FALSE}
echo arquivo_{1..3}_{A..C}

echo {1..3}

echo {1..30}

echo {A,T,G,C}{A,T,G,C}

echo {A,T,G,C} {A,T,G,C}



```

&nbsp;&nbsp;&nbsp;&nbsp; 
Todos os arquivos e diretórios podem ser movidos. O comando ***mv*** é utilizado para isto. Este comando tem uma sintaxe definida, e para seu funcionamento é preciso especificar duas coisas.

1) arquivo/diretório a ser movido;

2) arquivo/diretório de destino;

&nbsp;&nbsp;&nbsp;&nbsp; 
Este comando pode ser utilizado tanto para _mover_ (trocar de local) quanto para _renomear_ um arquivo ou diretório. Por isso, sua sintaxe deve ser analisada com calma antes da execução. Vamos vazer alguns testes.

> Remova todos os arquivos terminados em _D_.

```{bash, echo=TRUE,eval=FALSE}
ls

mv arquivo_1_D arquivo_1_D_renomeado

ls


```


&nbsp;&nbsp;&nbsp;&nbsp; 
Agora, vamos remover alguns arquivos. O comando ***rm*** é utilizado para remover arquivos. Já o comando ***rmdir***, para remover diretórios, necessáriamente vazios.

&nbsp;&nbsp;&nbsp;&nbsp; 
Não é possível _desfazer_ ações na linha de comando. Uma vez deletado, para sempre perdido. Assim, recomenda-se muita atenção na hora de executar comandos de remoção.
Uma opção é utilizar o argumento _-i_ para ativar a confirmação de remoção.

> Remova todos os arquivos terminados em _D_.

```{bash, echo=TRUE,eval=FALSE}
rm arquivo_1_D
rm arquivo_2_D

```

### Estrutura de diretórios

&nbsp;&nbsp;&nbsp;&nbsp;

> Utilize o comando ***tree*** para ver a estrutura de pastas a partir da sua ***$HOME***.

```{bash echo=TRUE,eval=TRUE}
tree ~/aula1 -L 2
```

&nbsp;&nbsp;&nbsp;&nbsp;
Note que o seu nome de usuário será diferente do meu, mostrado neste exemplo.

## Exercícios

&nbsp;&nbsp;&nbsp;&nbsp;
Utilizando os comandos que você aprendeu, execute as instruções a seguir. Sempre que pssível, utilize a tecla $TAB$ para completar os nomes de arquivos e caminhos. Lembre-se que o caracter $*$ serve como _coringa_, ele representa qualquer outro caracter.

> 1) mova os arquivos cujo nome começa com _arquivo_1_, _arquivo_2_ e _arquivo_3_ da pasta de onde eles foram criados para a pasta correspondente à última letra de seus nomes.

&nbsp;&nbsp;&nbsp;&nbsp;
Tente, com um único comando:

> 2) remover os arquivos com numeração _3_ de todas as pastas.

&nbsp;&nbsp;&nbsp;&nbsp;
Agora, vejamos como ficou a organização.

> 3) visualize a distribuição das subpastas e arquivos dentro da pasta _aula1_.






